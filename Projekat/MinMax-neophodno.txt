Potrebno za MinMax: //ovo samo za racunar radimo, potrebna jos funkcija kao u tudjem radu samo za racunar( gde je "poziv OPEN AI)
1. funkcija procene (imamo kao) //odrediti lepo heuristiku

2. moguci_potezi_igraca: Funkcija koja generiše sve moguće poteze za trenutno stanje igre.(imamo)

3. minimax: Glavna funkcija algoritma koja rekurzivno pretražuje stablo poteza. Ova funkcija se izvršava za svako stanje igre i 
           odabire najbolji potez za trenutnog igrača.

4. izvrsi_potez i ponisti_potez (opciono): Funkcije koje izvršavaju poteze i vraćaju igru u prethodno stanje.

5. alfa_beta: Pomoćna funkcija za alfa-beta odsecanje koje se koristi u rekurzivnom Minimax algoritmu za optimizaciju.
----------------------------------------------------------------------------------------------------------------------
Treba implementirati:
1. minimax algoritam sa alfa beta odsecanjem
2. funkcija za odigravanje partije izmedju coveka i potez_racunara
3. funckija procena stanja na osnovu pravila zakljucivanja
   (kao parametre treba da ima igrača za kojeg računa valjanost stanja, kao i samo stanje za koje se računa procena.)
   (Procena stanja se mora vršiti isključivo korišćenjem mehanizma zaključivanja nad prethodno definisanim skupom pravila. 
   Zadatak je formulisati skup pravila i iskoristiti ih na adekvatan način za izračunavanje heuristike.)
   (Za izvođenje potrebnih zaključaka (izvršavanje upita nad skupom činjenica kojima se opisuje stanje) koristiti mašinu za zaključivanje.)
4. funkcija koja prevodi stanje u listu cinjenica
----------------------------------------------------------------------------------------------------------------------
alfa beta u min max se koriste
zatim se poziva u igraj
ako je na potezu covek igra unesi potez
ako je racunar poziva se minmax i za njega postoji poseban unis poteza
----------------------------------------------------------------------------------------------------------------------
# Funkcija za ocenjivanje trenutnog stanja table
def evaluiraj(tabla):
    # Implementacija funkcije za evaluaciju trenutnog stanja table
    pass

# Glavna funkcija Minimax algoritma sa alfa-beta odsecanjem
def minimax_alpha_beta(tabla, dubina, alfa, beta, maximizing_player):
    # Baza rekurzije - provera da li je kraj igre ili dostignuta maksimalna dubina
    if dubina == 0 or kraj_igre(tabla):
        return evaluiraj(tabla)

    if maximizing_player:
        max_ocena = float('-inf')
        for potez in moguci_potezi(tabla):
            novo_stanje = primeni_potez(tabla, potez, 'X')  # Simulacija poteza računara
            ocena = minimax_alpha_beta(novo_stanje, dubina - 1, alfa, beta, False)
            max_ocena = max(max_ocena, ocena)
            alfa = max(alfa, ocena)
            if beta <= alfa:
                break  # Odsecanje grane
        return max_ocena
    else:
        min_ocena = float('inf')
        for potez in moguci_potezi(tabla):
            novo_stanje = primeni_potez(tabla, potez, 'O')  # Simulacija poteza igrača
            ocena = minimax_alpha_beta(novo_stanje, dubina - 1, alfa, beta, True)
            min_ocena = min(min_ocena, ocena)
            beta = min(beta, ocena)
            if beta <= alfa:
                break  # Odsecanje grane
        return min_ocena

# Funkcija koja simulira potez računara
def potez_racunara(tabla):
    najbolji_potez = None
    najbolja_ocena = float('-inf')
    alfa = float('-inf')
    beta = float('inf')
    for potez in moguci_potezi(tabla):
        novo_stanje = primeni_potez(tabla, potez, 'X')  # Simulacija poteza računara
        ocena = minimax_alpha_beta(novo_stanje, dubina, alfa, beta, False)
        if ocena > najbolja_ocena:
            najbolja_ocena = ocena
            najbolji_potez = potez
    return najbolji_potez

# Funkcija koja omogućava čoveku da odabere potez tokom igre
def potez_igraca():
    # Implementacija odabira poteza od strane igrača
    pass

# Kraj igre - funkcija koja proverava da li je igra završena
def kraj_igre(tabla):
    # Implementacija provere kraja igre
    pass

# Funkcija koja vraća listu mogućih poteza na osnovu trenutnog stanja table
def moguci_potezi(tabla):
    # Implementacija funkcije koja vraća listu mogućih poteza
    pass

# Funkcija koja primenjuje odabrani potez na tabelu
def primeni_potez(tabla, potez, igrac):
    # Implementacija funkcije za primenu poteza na tabelu
    pass
---------------------------------------------------------------------------------------------------------------
def igraj(self):
    broj_poteza = 0
    print(f"Prvi igrač je {self.igrac}.")

    while True:
        print(f"Igrač {self.igrac} je na potezu.")
        moguci_potezi = self.moguci_potezi_igraca(self.igrac)
        print("Procene")
        print(self.proceni_poteze(moguci_potezi))
        potez = self.unos_poteza()

        if self.valjanost_poteza(potez):
            print(self.proveri_kraj_igre())
            self.pomeri_figure(potez)
        else:
            print("Nemoguć potez.")
            continue

        print("Trenutna tabla:")
        self.crtaj_tablu()

        broj_poteza += 1

        # Ovde se menja redosled igrača na osnovu broja poteza
        if broj_poteza % 2 == 0:
            self.igrac = "X" if self.igrac == "O" else "O"
        else:
            # Pronađi figuru koja nije trenutna figura igrača
            preostala_figura = "X" if self.igrac == "O" else "O"

            # Generiši moguće poteze za preostalu figuru (računar)
            moguci_potezi_racunara = self.moguci_potezi_igraca(preostala_figura)

            # Izaberi nasumični potez za računar
            potez_racunar = self.odaberi_nasumicni_potez(moguci_potezi_racunara)

            # Primena poteza računara
            if self.valjanost_poteza(potez_racunar):
                self.pomeri_figure(potez_racunar)
                print(f"Računar je odigrao potez: {potez_racunar}")
            else:
                print("Računar je izabrao nevaljani potez.")

            print("Trenutna tabla:")
            self.crtaj_tablu()

    print("Kraj igre!")
